import _ from 'lodash';
import { Op } from 'sequelize';
import sequelize from '../connection';

function isExtrictedObject(val) {
  if (val === null) return false;
  return _.isObject(val) && !_.isArray(val);
}

export const transaction = fn => sequelize.transaction(fn);
// prettier-ignore
export const createTable = (tableName, defineTable) => (
  (queryInterface, Sequelize) => (
    transaction(() => queryInterface.createTable(tableName, defineTable(Sequelize)))
  )
);
// prettier-ignore
export const dropTable = tableName => (
  queryInterface => (
    transaction(() => queryInterface.dropTable(tableName))
  )
);

export const createAndDropTable = (tableName, defineTable) => ({
  up: createTable(tableName, defineTable),
  down: dropTable(tableName),
});

export const insertAndDeleteTable = (tableName, data) => ({
  up: queryInterface => transaction(() => queryInterface.bulkInsert(tableName, data)),
  down: queryInterface => queryInterface.bulkDelete(tableName),
});

export const timestampsColumns = Sequelize => ({
  createdAt: { type: Sequelize.DATE },
  updatedAt: { type: Sequelize.DATE },
  deletedAt: { type: Sequelize.DATE },
});

export async function upsert(model, value) {
  if (!value.id) return model.create(value);
  const instance = await model.findByPk(value.id);
  return instance.update(value);
}

export function upsertMany(model, values) {
  return Promise.all(values.map(val => upsert(model, val)));
}

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

export async function fullUpdate(model, id, body) {
  const instance = await model.findByPk(id);
  const allPromisses = Object.keys(model.associations).map(async (asscKey) => {
    if (body[asscKey]) {
      const result = await upsertMany(model.associations[asscKey].target, body[asscKey]);
      await instance[`set${capitalize(asscKey)}`](result);
      return 1;
    }
    return 0;
  });

  await Promise.all(allPromisses);

  return instance.update(body);
}

async function simpleValidate(model, values) {
  try {
    await model.build(values).validate();
    return [];
  } catch (error) {
    return [error];
  }
}

export async function getErrors(model, values) {
  const errors = await simpleValidate(model, values);
  const { uniqueKeys } = model;
  const uniqueQuery = Object.keys(uniqueKeys).map((key) => {
    const uniqueItem = {};
    uniqueKeys[key].fields.forEach((field) => {
      uniqueItem[field] = values[field];
    });
    return uniqueItem;
  });

  errors.push(
    await Promise.all(
      Object.keys(values)
        .filter(field => Array.isArray(values[field]))
        .map(async (field) => {
          const assocModel = model.associations[field].target;
          return Promise.all(values[field].map(assoc => getErrors(assocModel, assoc)));
        }),
    ),
  );

  errors.push(
    await Promise.all(
      Object.keys(values)
        .filter(field => isExtrictedObject(values[field]))
        .map(async (field) => {
          const assocModel = model.associations[field].target;
          return getErrors(assocModel, values[field]);
        }),
    ),
  );

  if (uniqueQuery.length === 0) {
    return errors;
  }
  const invalidUniqueCount = await model.count({ where: { [Op.or]: uniqueQuery } });
  if (invalidUniqueCount > 0) {
    errors.push(new Error(`unique ${uniqueQuery.map(x => Object.keys(x).join(',')).join(', ')}`));
  }
  return errors;
}

export async function validate(model, values) {
  const errors = await _.flattenDeep(await getErrors(model, values));
  if (errors.length > 0) throw new Error(errors.join(', '));
  return 1;
}

export async function verifyPk(model, id) {
  try {
    const instance = await model.findByPk(id, { raw: true, atributes: ['id'] });
    if (instance === null) throw new Error('Id no found');
  } catch (error) {
    throw new Error(error);
  }
}

export function autoGeneratedFields(model) {
  return (
    Object.values(model.rawAttributes)
      // eslint-disable-next-line no-underscore-dangle
      .filter(field => field._autoGenerated)
      .map(field => field.fieldName)
  );
}

export function unupdateFields(model) {
  return Object.values(model.rawAttributes)
    .filter(field => field.canUpdate === false)
    .map(field => field.fieldName);
}
